WEBVTT

00:00:00.000 --> 00:00:04.400
 Okay, fantastic. Okay guys, so we're

00:00:04.400 --> 00:00:07.900
 ready little technical difficulty here. So

00:00:07.900 --> 00:00:09.300
 for that reason, we have to

00:00:09.300 --> 00:00:12.400
 have the the middle screen, you

00:00:12.400 --> 00:00:14.200
 know to live on the on

00:00:14.200 --> 00:00:16.400
 the laptop for the duration of

00:00:16.400 --> 00:00:17.700
 the class and the two side

00:00:17.700 --> 00:00:19.800
 screens on the pad. You're okay

00:00:19.800 --> 00:00:24.600
 with that. Alright, so we have

00:00:24.600 --> 00:00:27.100
 not yet left the topic of

00:00:27.100 --> 00:00:29.400
 greedy. But you remember I mentioned

00:00:29.400 --> 00:00:31.000
 last time that for the next

00:00:31.000 --> 00:00:34.100
 couple problems that we want to

00:00:34.100 --> 00:00:37.000
 solve using the greedy method. We're

00:00:37.000 --> 00:00:39.800
 going to need some more advanced

00:00:39.800 --> 00:00:42.000
 data structures and that got us

00:00:42.000 --> 00:00:45.400
 into the discussion of priority choose

00:00:45.400 --> 00:00:48.000
 one way to implement a priority

00:00:48.000 --> 00:00:49.500
 queue we talked about last time

00:00:49.500 --> 00:00:54.500
 was binary heat right now a

00:00:54.500 --> 00:00:57.400
 priority to can be implemented using

00:00:57.400 --> 00:01:00.300
 as well. Just want to mention

00:01:00.300 --> 00:01:05.500
 those options as well. They're not

00:01:05.500 --> 00:01:07.000
 going to spend it out of

00:01:07.000 --> 00:01:09.300
 time on them. But I want

00:01:09.300 --> 00:01:10.700
 you guys to be aware of

00:01:10.700 --> 00:01:12.700
 the other types of heat that

00:01:12.700 --> 00:01:16.500
 are out there that can help

00:01:16.500 --> 00:01:20.600
 you implement a priority to And

00:01:20.600 --> 00:01:21.700
 then we're going to jump back

00:01:21.700 --> 00:01:29.400
 into greeting. So the first work.

00:01:29.400 --> 00:01:31.100
 Well, I should say the second

00:01:31.100 --> 00:01:33.300
 type of sheets that we want

00:01:33.300 --> 00:01:35.200
 to talk about is called the

00:01:35.200 --> 00:01:40.400
 binomial so binomial heaps. Are constructed

00:01:40.400 --> 00:01:42.600
 using binomial trees the same way

00:01:42.600 --> 00:01:45.900
 that a binary heat is constructed

00:01:45.900 --> 00:01:50.500
 using binary tree's binomial heat or

00:01:50.500 --> 00:01:56.000
 constructed using binomial treat. So definition

00:01:56.000 --> 00:01:59.100
 of what a binomial tree B2K

00:01:59.100 --> 00:02:03.300
 looks like so it's definition is

00:02:03.300 --> 00:02:05.700
 recursive. So so the binomial tree

00:02:05.700 --> 00:02:08.400
 B20 consist of only one note

00:02:08.400 --> 00:02:12.100
 a binomial tree bisa pakai consists

00:02:12.100 --> 00:02:14.000
 of two binomials trees piece of

00:02:14.000 --> 00:02:15.600
 K - 1 that are linked

00:02:15.600 --> 00:02:17.300
 together. So sad the root of

00:02:17.300 --> 00:02:20.100
 1 is the leftmost child of

00:02:20.100 --> 00:02:21.700
 the roots of the other show

00:02:21.700 --> 00:02:23.700
 me Sub-Zero is going to be

00:02:23.700 --> 00:02:26.500
 just one piece of one is

00:02:26.500 --> 00:02:28.100
 going to be to be Sub-Zero's

00:02:28.100 --> 00:02:29.900
 one is the left most child

00:02:29.900 --> 00:02:32.300
 of the other piece of shoe

00:02:32.300 --> 00:02:34.200
 you see it's to be someone

00:02:34.200 --> 00:02:35.500
 this is a piece of one.

00:02:35.500 --> 00:02:36.700
 This is a piece of one.

00:02:37.400 --> 00:02:39.200
 This piece of one is the

00:02:39.200 --> 00:02:41.800
 left most child of the root

00:02:41.800 --> 00:02:43.600
 of this other piece of want

00:02:43.600 --> 00:02:46.300
 this abusive 3, which is two

00:02:46.300 --> 00:02:48.300
 piece of tooth. This is one

00:02:48.300 --> 00:02:50.000
 piece up to this is another

00:02:50.000 --> 00:02:52.200
 be safe too. And this piece

00:02:52.200 --> 00:02:54.100
 of 2 is the leftmost child

00:02:54.100 --> 00:02:55.500
 of the root of the other

00:02:55.500 --> 00:02:59.800
 piece of 2K. So goes up

00:02:59.800 --> 00:03:01.700
 like that. So you see that

00:03:01.700 --> 00:03:08.000
 final meal tree nice, okay. It

00:03:08.000 --> 00:03:10.400
 has a fixed side. So if

00:03:10.400 --> 00:03:12.500
 you wanted to build a heap

00:03:12.500 --> 00:03:14.000
 that could be of any size.

00:03:15.100 --> 00:03:17.200
 Using binomial trees. What do you

00:03:17.200 --> 00:03:19.600
 have to do? You have to

00:03:19.600 --> 00:03:27.100
 use a combination of binomial tree

00:03:28.000 --> 00:03:30.500
 So here's a is the definition

00:03:30.500 --> 00:03:33.100
 of the binomial heat. So binomial

00:03:33.100 --> 00:03:36.500
 Heats H is is a set

00:03:36.500 --> 00:03:39.900
 of binomial tree. So this is

00:03:39.900 --> 00:03:43.600
 a contract with a fine binary

00:03:43.600 --> 00:03:46.400
 ink being constructed using only a

00:03:46.400 --> 00:03:50.000
 single binary tree. So the binomial

00:03:50.000 --> 00:03:54.400
 keep could consist of a number

00:03:54.400 --> 00:03:58.100
 of binomial tree. I have the

00:03:58.100 --> 00:04:01.700
 following property each binomial tree in

00:04:01.700 --> 00:04:04.500
 h a bass d.min. Heat property.

00:04:04.500 --> 00:04:06.200
 You guys remember the men he

00:04:06.200 --> 00:04:08.800
 property there the key value for

00:04:08.800 --> 00:04:13.400
 their nose. Is no larger. For

00:04:13.400 --> 00:04:14.900
 the men hip is is that

00:04:14.900 --> 00:04:18.900
 no less than the value corresponding

00:04:18.900 --> 00:04:22.400
 to the time? The other property

00:04:22.400 --> 00:04:24.600
 is that for any non-negative integer

00:04:24.600 --> 00:04:28.500
 K. There's at most one binomial

00:04:28.500 --> 00:04:30.700
 tree in h whose Roots has

00:04:30.700 --> 00:04:33.000
 degree K. So you can't you

00:04:33.000 --> 00:04:35.500
 can't have for example two piece

00:04:35.500 --> 00:04:37.700
 of to sort Ruby Civ 5

00:04:37.700 --> 00:04:43.600
 in a single binomial Heat. So

00:04:43.600 --> 00:04:45.700
 here's an example of a binomial

00:04:45.700 --> 00:04:53.800
 minty of size 7. Aerosol. in

00:04:53.800 --> 00:04:56.300
 a binomial heap of size 7

00:04:56.300 --> 00:04:57.500
 you see that you have a

00:04:57.500 --> 00:05:00.100
 decent 0 you have a piece

00:05:00.100 --> 00:05:01.200
 of one and you had a

00:05:01.200 --> 00:05:08.100
 visa to so How is 7

00:05:08.100 --> 00:05:17.500
 represented in binary? It is 7

00:05:17.500 --> 00:05:24.800
 in binary is what? it's a

00:05:26.800 --> 00:05:29.500
 how many zeros do you have

00:05:29.500 --> 00:05:31.500
 there? And then you have one

00:05:31.500 --> 00:05:36.700
 one and one right? So you

00:05:36.700 --> 00:05:40.000
 can actually think of the the

00:05:40.000 --> 00:05:44.100
 binary bind up the binomial trees

00:05:44.100 --> 00:05:45.800
 that you do you end up

00:05:45.800 --> 00:05:49.000
 with in a binary binomial live

00:05:49.000 --> 00:05:52.900
 in terms of the the the

00:05:52.900 --> 00:05:59.000
 bits representing the size of of

00:05:59.000 --> 00:06:01.500
 the heat in binary. So for

00:06:01.500 --> 00:06:07.100
 example, Inapposite that left right most

00:06:07.100 --> 00:06:08.900
 position you have a one so

00:06:08.900 --> 00:06:09.900
 it means that you have a

00:06:09.900 --> 00:06:12.300
 Visa Bureau the second one you

00:06:12.300 --> 00:06:15.000
 have again. I want it means

00:06:15.000 --> 00:06:16.900
 they have a Visa and a

00:06:16.900 --> 00:06:18.900
 certain position you have a one

00:06:18.900 --> 00:06:20.200
 is being said you have a

00:06:20.200 --> 00:06:23.100
 piece of two as well right

00:06:23.100 --> 00:06:26.200
 now. What is the representation of

00:06:26.200 --> 00:06:32.800
 8? so 8 in binary is

00:06:32.800 --> 00:06:37.200
 going to look like That's right.

00:06:37.200 --> 00:06:39.000
 So what does that mean? How

00:06:39.000 --> 00:06:41.700
 many how many binomial trees are

00:06:41.700 --> 00:06:43.400
 you going to have in a

00:06:43.400 --> 00:06:48.200
 binomial heat a size 8? this

00:06:48.200 --> 00:06:51.900
 one and that would be ABI

00:06:51.900 --> 00:06:56.900
 Saab a piece of three remember

00:07:00.200 --> 00:07:03.000
 piece of three has eight notes

00:07:03.000 --> 00:07:08.100
 exactly eight notes in it. All

00:07:08.100 --> 00:07:09.600
 right. Now as you can see

00:07:09.600 --> 00:07:14.500
 each one of these binary, I'm

00:07:14.500 --> 00:07:16.000
 sorry. Goodbye. And each one of

00:07:16.000 --> 00:07:19.200
 the binomial trees have the mini

00:07:19.200 --> 00:07:23.300
 property. But if you're trying to

00:07:23.300 --> 00:07:26.700
 find the the smallest element in

00:07:26.700 --> 00:07:31.100
 the Min Heap. Let's say this

00:07:31.100 --> 00:07:33.200
 is the head of the the

00:07:33.200 --> 00:07:34.200
 heat from this is this is

00:07:34.200 --> 00:07:36.200
 a pointer to to them in

00:07:36.200 --> 00:07:40.100
 heat. Can you just pick this

00:07:40.100 --> 00:07:45.100
 element? No, because the minimum elements

00:07:45.100 --> 00:07:47.300
 could be over here or here

00:07:47.300 --> 00:07:49.800
 or hear it could be at

00:07:49.800 --> 00:07:52.300
 one of the roots of the

00:07:52.300 --> 00:07:56.300
 binomial tree. So how long would

00:07:56.300 --> 00:07:59.700
 it take us to to go

00:07:59.700 --> 00:08:02.500
 and search through the split but

00:08:02.500 --> 00:08:05.300
 say you have an element's in

00:08:05.300 --> 00:08:07.600
 the ruthless. How long does it

00:08:07.600 --> 00:08:09.400
 take us to go in search

00:08:09.400 --> 00:08:11.400
 this ruthless and then we have

00:08:11.400 --> 00:08:13.100
 to basically go through the ruthless

00:08:13.100 --> 00:08:16.900
 linearly. So how long would it

00:08:16.900 --> 00:08:23.000
 take? if you have any elements

00:08:23.000 --> 00:08:25.800
 in the portal in the binomial,

00:08:25.800 --> 00:08:29.800
 how many routes can you have

00:08:29.800 --> 00:08:35.000
 in the in the ruthless how

00:08:35.000 --> 00:08:36.200
 many elements can you have in

00:08:36.200 --> 00:08:39.900
 the route list? Ann Arbor the

00:08:39.900 --> 00:08:44.900
 each one of these trees would

00:08:44.900 --> 00:08:46.900
 correspond to one of these bits

00:08:46.900 --> 00:08:49.100
 in a binary representation of the

00:08:49.100 --> 00:08:52.000
 size of the binomial heat. So

00:08:52.000 --> 00:08:55.000
 to represent 10 in binary, how

00:08:55.000 --> 00:08:59.000
 many bits do you need? you

00:08:59.000 --> 00:09:04.300
 need log and dip so Then

00:09:04.300 --> 00:09:07.700
 the maximum number of the trees

00:09:07.700 --> 00:09:09.500
 that you would have in the

00:09:09.500 --> 00:09:11.300
 in the ruthless is going to

00:09:11.300 --> 00:09:16.300
 be. login Do you like the

00:09:16.300 --> 00:09:17.800
 the light show that we have?

00:09:19.700 --> 00:09:33.100
 Thank you, Andrew. Do you need

00:09:33.100 --> 00:09:39.800
 a minute? Yeah, I'm do. Yeah,

00:09:39.800 --> 00:09:47.500
 sure. 30 seconds. Andrew says no

00:09:47.500 --> 00:11:19.300
 pressure. You think we are in

00:11:19.300 --> 00:11:44.300
 a stable 45 seconds? Okay, we're

00:11:44.300 --> 00:11:48.500
 good. All right. Okay, so so

00:11:48.500 --> 00:11:52.200
 let's see. Alright, so before we

00:11:52.200 --> 00:11:57.500
 leave this. To find the minimum

00:11:57.500 --> 00:12:00.700
 elements so find men. We just

00:12:00.700 --> 00:12:02.100
 talked about it. It takes a

00:12:02.100 --> 00:12:06.400
 while. Lol again because this Miss

00:12:06.400 --> 00:12:08.700
 Goody login long, they can be

00:12:08.700 --> 00:12:10.600
 log and trees involved. They have

00:12:10.600 --> 00:12:12.400
 to search the root for Soul

00:12:12.400 --> 00:12:16.200
 Men. The fine men takes login

00:12:16.200 --> 00:12:17.900
 time. Remember to sign in in

00:12:17.900 --> 00:12:19.800
 a binary. He took how long

00:12:21.900 --> 00:12:24.300
 And it took us a time

00:12:24.300 --> 00:12:25.600
 because you knew exactly where it

00:12:25.600 --> 00:12:28.100
 was. It was sitting position in

00:12:28.100 --> 00:12:30.900
 the array. Okay, so I could

00:12:30.900 --> 00:12:33.400
 actually taste login time worse case

00:12:33.400 --> 00:12:36.500
 now. Let's see how the insert

00:12:36.500 --> 00:12:39.300
 operation is going to work. So

00:12:39.300 --> 00:12:42.100
 let's say I'm going to insert.

00:12:45.900 --> 00:12:49.300
 an element with with a t

00:12:49.300 --> 00:12:52.300
 value of 9 into the seat,

00:12:52.300 --> 00:12:57.600
 so Can I just say well

00:12:57.600 --> 00:13:00.000
 I'm going to add this element

00:13:00.000 --> 00:13:02.100
 9 in The Roots list. And

00:13:02.100 --> 00:13:05.000
 the rest of it is going

00:13:05.000 --> 00:13:07.300
 to stay the same. Well, no

00:13:07.300 --> 00:13:08.900
 because what you remember one of

00:13:08.900 --> 00:13:12.700
 those constraints one of those properties

00:13:12.700 --> 00:13:15.800
 in a binomial Heap is that

00:13:15.800 --> 00:13:18.100
 you cannot have two piece of

00:13:18.100 --> 00:13:20.300
 cake so you cannot have to

00:13:20.300 --> 00:13:21.600
 be Sbarro's in that you've liked

00:13:21.600 --> 00:13:22.200
 it. So what do you have

00:13:22.200 --> 00:13:25.400
 to do you have to merge

00:13:25.400 --> 00:13:29.800
 them together? So so which one

00:13:29.800 --> 00:13:32.200
 becomes the left of the other

00:13:32.200 --> 00:13:34.100
 if this is this is a

00:13:34.100 --> 00:13:39.400
 Min he 12 becomes the leftmost

00:13:39.400 --> 00:13:44.200
 filed of 9 right and then

00:13:44.200 --> 00:13:47.900
 I'm very happy the seven and

00:13:47.900 --> 00:13:51.700
 the 10 and so forth now,

00:13:51.700 --> 00:13:55.200
 is it better to be someone?

00:13:56.200 --> 00:13:58.200
 So we have some birds he's

00:13:58.200 --> 00:14:00.200
 too which one becomes the leftmost

00:14:00.200 --> 00:14:04.400
 child. The one with the root

00:14:04.400 --> 00:14:06.200
 note having a value of 9

00:14:06.200 --> 00:14:08.900
 G Body of night. So then
